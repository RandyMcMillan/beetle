#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
#[macro_use]
mod macros {}
mod client {
    use anyhow::{anyhow, Context, Result};
    #[cfg(feature = "grpc")]
    use futures::{Stream, StreamExt};
    use crate::config::Config;
    use crate::gateway::GatewayClient;
    use crate::network::P2pClient;
    use crate::store::StoreClient;
    pub struct Client {
        pub gateway: Option<GatewayClient>,
        pub p2p: Option<P2pClient>,
        pub store: Option<StoreClient>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Client {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Client",
                "gateway",
                &&self.gateway,
                "p2p",
                &&self.p2p,
                "store",
                &&self.store,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Client {
        #[inline]
        fn clone(&self) -> Client {
            Client {
                gateway: ::core::clone::Clone::clone(&self.gateway),
                p2p: ::core::clone::Clone::clone(&self.p2p),
                store: ::core::clone::Clone::clone(&self.store),
            }
        }
    }
    impl Client {
        pub async fn new(cfg: Config) -> Result<Self> {
            let Config { gateway_addr, p2p_addr, store_addr } = cfg;
            let gateway = if let Some(addr) = gateway_addr {
                Some(
                    GatewayClient::new(addr)
                        .await
                        .context("Could not create gateway rpc client")?,
                )
            } else {
                None
            };
            let p2p = if let Some(addr) = p2p_addr {
                Some(
                    P2pClient::new(addr)
                        .await
                        .context("Could not create p2p rpc client")?,
                )
            } else {
                None
            };
            let store = if let Some(addr) = store_addr {
                Some(
                    StoreClient::new(addr)
                        .await
                        .context("Could not create store rpc client")?,
                )
            } else {
                None
            };
            Ok(Client { gateway, p2p, store })
        }
        pub fn try_p2p(&self) -> Result<&P2pClient> {
            self.p2p
                .as_ref()
                .ok_or_else(|| ::anyhow::__private::must_use({
                    let error = ::anyhow::__private::format_err(
                        ::core::fmt::Arguments::new_v1(
                            &["missing rpc p2p connnection"],
                            &[],
                        ),
                    );
                    error
                }))
        }
        pub fn try_gateway(&self) -> Result<&GatewayClient> {
            self.gateway
                .as_ref()
                .ok_or_else(|| ::anyhow::__private::must_use({
                    let error = ::anyhow::__private::format_err(
                        ::core::fmt::Arguments::new_v1(
                            &["missing rpc gateway connnection"],
                            &[],
                        ),
                    );
                    error
                }))
        }
        pub fn try_store(&self) -> Result<&StoreClient> {
            self.store
                .as_ref()
                .ok_or_else(|| ::anyhow::__private::must_use({
                    let error = ::anyhow::__private::format_err(
                        ::core::fmt::Arguments::new_v1(
                            &["missing rpc store connnection"],
                            &[],
                        ),
                    );
                    error
                }))
        }
        #[cfg(feature = "grpc")]
        pub async fn check(&self) -> crate::status::StatusTable {
            let g = if let Some(ref g) = self.gateway {
                Some(g.check().await)
            } else {
                None
            };
            let p = if let Some(ref p) = self.p2p {
                Some(p.check().await)
            } else {
                None
            };
            let s = if let Some(ref s) = self.store {
                Some(s.check().await)
            } else {
                None
            };
            crate::status::StatusTable::new(g, p, s)
        }
        #[cfg(feature = "grpc")]
        pub async fn watch(self) -> impl Stream<Item = crate::status::StatusTable> {
            {
                let (mut __yield_tx, __yield_rx) = ::async_stream::yielder::pair();
                ::async_stream::AsyncStream::new(
                    __yield_rx,
                    async move {
                        let mut status_table: crate::status::StatusTable = Default::default();
                        let mut streams = Vec::new();
                        if let Some(ref g) = self.gateway {
                            let g = g.watch().await;
                            streams.push(g.boxed());
                        }
                        if let Some(ref p) = self.p2p {
                            let p = p.watch().await;
                            streams.push(p.boxed());
                        }
                        if let Some(ref s) = self.store {
                            let s = s.watch().await;
                            streams.push(s.boxed());
                        }
                        let mut stream = futures::stream::select_all(streams);
                        while let Some(status) = stream.next().await {
                            status_table.update(status).unwrap();
                            __yield_tx.send(status_table.clone()).await;
                        }
                    },
                )
            }
        }
    }
}
mod config {
    use config::{ConfigError, Map, Source, Value};
    use iroh_rpc_types::{
        gateway::GatewayClientAddr, p2p::P2pClientAddr, store::StoreClientAddr,
    };
    use iroh_util::insert_into_config_map;
    use serde::{Deserialize, Serialize};
    pub struct Config {
        pub gateway_addr: Option<GatewayClientAddr>,
        pub p2p_addr: Option<P2pClientAddr>,
        pub store_addr: Option<StoreClientAddr>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Config {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Config",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "gateway_addr",
                    &self.gateway_addr,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "p2p_addr",
                    &self.p2p_addr,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "store_addr",
                    &self.store_addr,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Config {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "gateway_addr" => _serde::__private::Ok(__Field::__field0),
                            "p2p_addr" => _serde::__private::Ok(__Field::__field1),
                            "store_addr" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"gateway_addr" => _serde::__private::Ok(__Field::__field0),
                            b"p2p_addr" => _serde::__private::Ok(__Field::__field1),
                            b"store_addr" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Config>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Config;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Config",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Option<GatewayClientAddr>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Config with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<P2pClientAddr>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Config with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Option<StoreClientAddr>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Config with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Config {
                            gateway_addr: __field0,
                            p2p_addr: __field1,
                            store_addr: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Option<GatewayClientAddr>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<P2pClientAddr>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<StoreClientAddr>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key)
                            = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "gateway_addr",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<GatewayClientAddr>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "p2p_addr",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<P2pClientAddr>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "store_addr",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<StoreClientAddr>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("gateway_addr") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("p2p_addr") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("store_addr") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Config {
                            gateway_addr: __field0,
                            p2p_addr: __field1,
                            store_addr: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "gateway_addr",
                    "p2p_addr",
                    "store_addr",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Config",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Config>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Config {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Config",
                "gateway_addr",
                &&self.gateway_addr,
                "p2p_addr",
                &&self.p2p_addr,
                "store_addr",
                &&self.store_addr,
            )
        }
    }
    impl ::core::marker::StructuralPartialEq for Config {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Config {
        #[inline]
        fn eq(&self, other: &Config) -> bool {
            self.gateway_addr == other.gateway_addr && self.p2p_addr == other.p2p_addr
                && self.store_addr == other.store_addr
        }
        #[inline]
        fn ne(&self, other: &Config) -> bool {
            self.gateway_addr != other.gateway_addr || self.p2p_addr != other.p2p_addr
                || self.store_addr != other.store_addr
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Config {
        #[inline]
        fn clone(&self) -> Config {
            Config {
                gateway_addr: ::core::clone::Clone::clone(&self.gateway_addr),
                p2p_addr: ::core::clone::Clone::clone(&self.p2p_addr),
                store_addr: ::core::clone::Clone::clone(&self.store_addr),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Config {
        #[inline]
        fn default() -> Config {
            Config {
                gateway_addr: ::core::default::Default::default(),
                p2p_addr: ::core::default::Default::default(),
                store_addr: ::core::default::Default::default(),
            }
        }
    }
    impl Source for Config {
        fn clone_into_box(&self) -> Box<dyn Source + Send + Sync> {
            Box::new(self.clone())
        }
        fn collect(&self) -> Result<Map<String, Value>, ConfigError> {
            let mut map: Map<String, Value> = Map::new();
            if let Some(addr) = &self.gateway_addr {
                insert_into_config_map(&mut map, "gateway_addr", addr.to_string());
            }
            if let Some(addr) = &self.p2p_addr {
                insert_into_config_map(&mut map, "p2p_addr", addr.to_string());
            }
            if let Some(addr) = &self.store_addr {
                insert_into_config_map(&mut map, "store_addr", addr.to_string());
            }
            Ok(map)
        }
    }
    impl Config {
        pub fn default_grpc() -> Self {
            Self {
                gateway_addr: Some("grpc://0.0.0.0:4400".parse().unwrap()),
                p2p_addr: Some("grpc://0.0.0.0:4401".parse().unwrap()),
                store_addr: Some("grpc://0.0.0.0:4402".parse().unwrap()),
            }
        }
    }
}
mod gateway {
    #[cfg(feature = "grpc")]
    use crate::status::{self, StatusRow};
    use anyhow::Result;
    #[cfg(feature = "grpc")]
    use futures::Stream;
    #[cfg(feature = "grpc")]
    use iroh_rpc_types::gateway::gateway_client::GatewayClient as GrpcGatewayClient;
    use iroh_rpc_types::{
        gateway::{Gateway, GatewayClientAddr, GatewayClientBackend},
        Addr,
    };
    #[cfg(feature = "grpc")]
    use tonic::transport::Endpoint;
    #[cfg(feature = "grpc")]
    use tonic_health::proto::health_client::HealthClient;
    /// Name that the health service registers the client,
    /// as this is derived from the protobuf definition.
    #[cfg(feature = "grpc")]
    pub(crate) const SERVICE_NAME: &str = "gateway.Gateway";
    /// The display name that we expect to see in the StatusTable.
    #[cfg(feature = "grpc")]
    pub(crate) const NAME: &str = "gateway";
    pub struct GatewayClient {
        backend: GatewayClientBackend,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for GatewayClient {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "GatewayClient",
                "backend",
                &&self.backend,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GatewayClient {
        #[inline]
        fn clone(&self) -> GatewayClient {
            GatewayClient {
                backend: ::core::clone::Clone::clone(&self.backend),
            }
        }
    }
    impl GatewayClient {
        pub async fn new(addr: GatewayClientAddr) -> Result<Self> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event iroh-rpc-client/src/gateway.rs:17",
                            "iroh_rpc_client::gateway",
                            ::tracing::Level::INFO,
                            Some("iroh-rpc-client/src/gateway.rs"),
                            Some(17u32),
                            Some("iroh_rpc_client::gateway"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = CALLSITE.metadata().fields().iter();
                        CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                        Some(
                                            &::core::fmt::Arguments::new_v1(
                                                &["connecting to "],
                                                &[::core::fmt::ArgumentV1::new_display(&addr)],
                                            ) as &Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                Some(
                                                                    &::core::fmt::Arguments::new_v1(
                                                                        &["connecting to "],
                                                                        &[::core::fmt::ArgumentV1::new_display(&addr)],
                                                                    ) as &Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            match addr {
                #[cfg(feature = "grpc")]
                Addr::GrpcHttp2(addr) => {
                    let conn = Endpoint::new({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["http://"],
                                    &[::core::fmt::ArgumentV1::new_display(&addr)],
                                ),
                            );
                            res
                        })?
                        .keep_alive_while_idle(true)
                        .connect_lazy();
                    let client = GrpcGatewayClient::new(conn.clone());
                    let health = HealthClient::new(conn);
                    Ok(GatewayClient {
                        backend: GatewayClientBackend::Grpc {
                            client,
                            health,
                        },
                    })
                }
                #[cfg(all(feature = "grpc", unix))]
                Addr::GrpcUds(path) => {
                    use tokio::net::UnixStream;
                    use tonic::transport::Uri;
                    let path = std::sync::Arc::new(path);
                    let conn = Endpoint::new("http://[..]:50051")?
                        .keep_alive_while_idle(true)
                        .connect_with_connector_lazy(
                            tower::service_fn(move |_: Uri| {
                                let path = path.clone();
                                UnixStream::connect(path.as_ref().clone())
                            }),
                        );
                    let client = GrpcGatewayClient::new(conn.clone());
                    let health = HealthClient::new(conn);
                    Ok(GatewayClient {
                        backend: GatewayClientBackend::Grpc {
                            client,
                            health,
                        },
                    })
                }
                #[cfg(feature = "mem")]
                Addr::Mem(s) => {
                    Ok(GatewayClient {
                        backend: GatewayClientBackend::Mem(s),
                    })
                }
            }
        }
        #[cfg(feature = "grpc")]
        pub async fn check(&self) -> StatusRow {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "check",
                            "iroh_rpc_client::gateway",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/gateway.rs"),
                            Some(17u32),
                            Some("iroh_rpc_client::gateway"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                match &self.backend {
                    GatewayClientBackend::Grpc { health, .. } => {
                        status::check(health.clone(), SERVICE_NAME, NAME).await
                    }
                    _ => ::core::panicking::panic("not yet implemented"),
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[cfg(feature = "grpc")]
        pub async fn watch(&self) -> impl Stream<Item = StatusRow> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "watch",
                            "iroh_rpc_client::gateway",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/gateway.rs"),
                            Some(17u32),
                            Some("iroh_rpc_client::gateway"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                match &self.backend {
                    GatewayClientBackend::Grpc { health, .. } => {
                        status::watch(health.clone(), SERVICE_NAME, NAME).await
                    }
                    _ => ::core::panicking::panic("not yet implemented"),
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
    impl GatewayClient {
        pub async fn version(&self) -> Result<String> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "version",
                            "iroh_rpc_client::gateway",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/gateway.rs"),
                            Some(20u32),
                            Some("iroh_rpc_client::gateway"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let res = self.backend.clone().version(()).await?;
                Ok(res.version)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
}
mod network {
    use std::collections::{HashMap, HashSet};
    use anyhow::{ensure, Context, Result};
    use bytes::Bytes;
    use cid::Cid;
    #[cfg(feature = "grpc")]
    use futures::{Stream, StreamExt};
    #[cfg(feature = "grpc")]
    use iroh_rpc_types::p2p::p2p_client::P2pClient as GrpcP2pClient;
    use iroh_rpc_types::p2p::{
        BitswapRequest, ConnectRequest, DisconnectRequest, GossipsubPeerAndTopics,
        GossipsubPeerIdMsg, GossipsubPublishRequest, GossipsubTopicHashMsg, Key, P2p,
        P2pClientAddr, P2pClientBackend, Providers,
    };
    use iroh_rpc_types::Addr;
    use libp2p::gossipsub::{MessageId, TopicHash};
    use libp2p::{Multiaddr, PeerId};
    #[cfg(feature = "grpc")]
    use tonic::transport::Endpoint;
    #[cfg(feature = "grpc")]
    use tonic_health::proto::health_client::HealthClient;
    use tracing::{debug, warn};
    #[cfg(feature = "grpc")]
    use crate::status::{self, StatusRow};
    /// Name that the health service registers the client,
    /// as this is derived from the protobuf definition.
    #[cfg(feature = "grpc")]
    pub(crate) const SERVICE_NAME: &str = "p2p.P2p";
    /// The display name that we expect to see in the StatusTable.
    #[cfg(feature = "grpc")]
    pub(crate) const NAME: &str = "p2p";
    pub struct P2pClient {
        backend: P2pClientBackend,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for P2pClient {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "P2pClient",
                "backend",
                &&self.backend,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for P2pClient {
        #[inline]
        fn clone(&self) -> P2pClient {
            P2pClient {
                backend: ::core::clone::Clone::clone(&self.backend),
            }
        }
    }
    impl P2pClient {
        pub async fn new(addr: P2pClientAddr) -> Result<Self> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event iroh-rpc-client/src/network.rs:27",
                            "iroh_rpc_client::network",
                            ::tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(27u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = CALLSITE.metadata().fields().iter();
                        CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                        Some(
                                            &::core::fmt::Arguments::new_v1(
                                                &["connecting to "],
                                                &[::core::fmt::ArgumentV1::new_display(&addr)],
                                            ) as &Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                Some(
                                                                    &::core::fmt::Arguments::new_v1(
                                                                        &["connecting to "],
                                                                        &[::core::fmt::ArgumentV1::new_display(&addr)],
                                                                    ) as &Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            match addr {
                #[cfg(feature = "grpc")]
                Addr::GrpcHttp2(addr) => {
                    let conn = Endpoint::new({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["http://"],
                                    &[::core::fmt::ArgumentV1::new_display(&addr)],
                                ),
                            );
                            res
                        })?
                        .keep_alive_while_idle(true)
                        .connect_lazy();
                    let client = GrpcP2pClient::new(conn.clone());
                    let health = HealthClient::new(conn);
                    Ok(P2pClient {
                        backend: P2pClientBackend::Grpc {
                            client,
                            health,
                        },
                    })
                }
                #[cfg(all(feature = "grpc", unix))]
                Addr::GrpcUds(path) => {
                    use tokio::net::UnixStream;
                    use tonic::transport::Uri;
                    let path = std::sync::Arc::new(path);
                    let conn = Endpoint::new("http://[..]:50051")?
                        .keep_alive_while_idle(true)
                        .connect_with_connector_lazy(
                            tower::service_fn(move |_: Uri| {
                                let path = path.clone();
                                UnixStream::connect(path.as_ref().clone())
                            }),
                        );
                    let client = GrpcP2pClient::new(conn.clone());
                    let health = HealthClient::new(conn);
                    Ok(P2pClient {
                        backend: P2pClientBackend::Grpc {
                            client,
                            health,
                        },
                    })
                }
                #[cfg(feature = "mem")]
                Addr::Mem(s) => {
                    Ok(P2pClient {
                        backend: P2pClientBackend::Mem(s),
                    })
                }
            }
        }
        #[cfg(feature = "grpc")]
        pub async fn check(&self) -> StatusRow {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "check",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(27u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                match &self.backend {
                    P2pClientBackend::Grpc { health, .. } => {
                        status::check(health.clone(), SERVICE_NAME, NAME).await
                    }
                    _ => ::core::panicking::panic("not yet implemented"),
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[cfg(feature = "grpc")]
        pub async fn watch(&self) -> impl Stream<Item = StatusRow> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "watch",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(27u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                match &self.backend {
                    P2pClientBackend::Grpc { health, .. } => {
                        status::watch(health.clone(), SERVICE_NAME, NAME).await
                    }
                    _ => ::core::panicking::panic("not yet implemented"),
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
    impl P2pClient {
        pub async fn version(&self) -> Result<String> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "version",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(30u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let res = self.backend.version(()).await?;
                Ok(res.version)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn fetch_bitswap(
            &self,
            cid: Cid,
            providers: HashSet<PeerId>,
        ) -> Result<Bytes> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "fetch_bitswap",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(37u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["cid", "providers"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&cid) as &Value),
                                        ),
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&providers) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&cid) as &Value),
                                                    ),
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&providers) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event iroh-rpc-client/src/network.rs:39",
                                "iroh_rpc_client::network",
                                ::tracing::Level::DEBUG,
                                Some("iroh-rpc-client/src/network.rs"),
                                Some(39u32),
                                Some("iroh_rpc_client::network"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::DEBUG {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::DEBUG {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(
                                                &::core::fmt::Arguments::new_v1(
                                                    &["rpc p2p client fetch_bitswap: "],
                                                    &[::core::fmt::ArgumentV1::new_debug(&cid)],
                                                ) as &Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::DEBUG {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::DEBUG {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = CALLSITE.metadata().fields().iter();
                                                    CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(
                                                                        &::core::fmt::Arguments::new_v1(
                                                                            &["rpc p2p client fetch_bitswap: "],
                                                                            &[::core::fmt::ArgumentV1::new_debug(&cid)],
                                                                        ) as &Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                let providers = Providers {
                    providers: providers.into_iter().map(|id| id.to_bytes()).collect(),
                };
                let req = BitswapRequest {
                    cid: cid.to_bytes(),
                    providers: Some(providers),
                };
                let res = self.clone().backend.clone().fetch_bitswap(req).await?;
                Ok(res.data)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        /// Injects additional providers for the given CID
        pub async fn inject_provider_bitswap(
            &self,
            cid: Cid,
            providers: HashSet<PeerId>,
        ) -> Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "inject_provider_bitswap",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(53u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["cid", "providers"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&cid) as &Value),
                                        ),
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&providers) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&cid) as &Value),
                                                    ),
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&providers) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let providers = Providers {
                    providers: providers.into_iter().map(|id| id.to_bytes()).collect(),
                };
                let req = BitswapRequest {
                    cid: cid.to_bytes(),
                    providers: Some(providers),
                };
                self.backend.inject_provider_bitswap(req).await?;
                Ok(())
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn fetch_providers_dht(
            &self,
            key: &Cid,
        ) -> Result<impl Stream<Item = Result<HashSet<PeerId>>>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "fetch_providers_dht",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(71u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["key"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&key) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&key) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = Key { key: key.hash().to_bytes() };
                let res = self.backend.fetch_provider_dht(req).await?;
                let providers_stream = res
                    .map(|p| {
                        let p = p?;
                        let mut providers = HashSet::new();
                        for provider in p.providers.into_iter() {
                            providers.insert(PeerId::from_bytes(&provider[..])?);
                        }
                        Ok(providers)
                    });
                Ok(providers_stream)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn fetch_providers_bitswap(
            &self,
            key: &Cid,
        ) -> Result<impl Stream<Item = Result<HashSet<PeerId>>>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "fetch_providers_bitswap",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(92u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["key"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&key) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&key) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = Key { key: key.to_bytes() };
                let res = self.backend.fetch_provider_bitswap(req).await?;
                let providers_stream = res
                    .map(|p| {
                        let p = p?;
                        let mut providers = HashSet::new();
                        for provider in p.providers.into_iter() {
                            providers.insert(PeerId::from_bytes(&provider[..])?);
                        }
                        Ok(providers)
                    });
                Ok(providers_stream)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn get_listening_addrs(&self) -> Result<(PeerId, Vec<Multiaddr>)> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get_listening_addrs",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(112u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let res = self.backend.get_listening_addrs(()).await?;
                let peer_id = PeerId::from_bytes(&res.peer_id[..])?;
                let addrs = addrs_from_bytes(res.addrs)?;
                Ok((peer_id, addrs))
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn get_peers(&self) -> Result<HashMap<PeerId, Vec<Multiaddr>>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get_peers",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(120u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let peers = self.backend.get_peers(()).await?.peers;
                let mut peers_map = HashMap::new();
                for (peer, addrs) in peers.into_iter() {
                    let peer = peer.parse()?;
                    let addrs = addrs_from_bytes(addrs.addrs)?;
                    peers_map.insert(peer, addrs);
                }
                Ok(peers_map)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn connect(
            &self,
            peer_id: PeerId,
            addrs: Vec<Multiaddr>,
        ) -> Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "connect",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(132u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["peer_id", "addrs"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&peer_id) as &Value),
                                        ),
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&addrs) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&peer_id) as &Value),
                                                    ),
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&addrs) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = ConnectRequest {
                    peer_id: peer_id.to_bytes(),
                    addrs: addrs.iter().map(|a| a.to_vec()).collect(),
                };
                let res = self.backend.peer_connect(req).await?;
                if !res.success {
                    return ::anyhow::__private::Err({
                        let error = ::anyhow::__private::format_err(
                            ::core::fmt::Arguments::new_v1(&["dial failed"], &[]),
                        );
                        error
                    });
                }
                Ok(())
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn disconnect(&self, peer_id: PeerId) -> Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "disconnect",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(143u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["peer_id"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&peer_id) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&peer_id) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event iroh-rpc-client/src/network.rs:145",
                                "iroh_rpc_client::network",
                                ::tracing::Level::WARN,
                                Some("iroh-rpc-client/src/network.rs"),
                                Some(145u32),
                                Some("iroh_rpc_client::network"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(
                                                &::core::fmt::Arguments::new_v1(
                                                    &["NetDisconnect not yet implemented on p2p node"],
                                                    &[],
                                                ) as &Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::WARN {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = CALLSITE.metadata().fields().iter();
                                                    CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                    Some(
                                                                        &::core::fmt::Arguments::new_v1(
                                                                            &["NetDisconnect not yet implemented on p2p node"],
                                                                            &[],
                                                                        ) as &Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
                let req = DisconnectRequest {
                    peer_id: peer_id.to_bytes(),
                };
                self.backend.peer_disconnect(req).await?;
                Ok(())
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn shutdown(&self) -> Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "shutdown",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(153u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                self.backend.shutdown(()).await?;
                Ok(())
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_add_explicit_peer(&self, peer_id: PeerId) -> Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_add_explicit_peer",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(159u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["peer_id"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&peer_id) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&peer_id) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GossipsubPeerIdMsg {
                    peer_id: peer_id.to_bytes(),
                };
                self.backend.gossipsub_add_explicit_peer(req).await?;
                Ok(())
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_all_mesh_peers(&self) -> Result<Vec<PeerId>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_all_mesh_peers",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(168u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let res = self.backend.gossipsub_all_mesh_peers(()).await?;
                let peer_ids = peer_ids_from_bytes(res.peers)?;
                Ok(peer_ids)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_all_peers(
            &self,
        ) -> Result<Vec<(PeerId, Vec<TopicHash>)>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_all_peers",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(175u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let res = self.backend.gossipsub_all_peers(()).await?.all;
                let peers_and_topics = all_peers_from_bytes(res)?;
                Ok(peers_and_topics)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_mesh_peers(
            &self,
            topic: TopicHash,
        ) -> Result<Vec<PeerId>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_mesh_peers",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(182u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["topic"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&topic) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&topic) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GossipsubTopicHashMsg {
                    topic_hash: topic.into_string(),
                };
                let res = self.backend.gossipsub_mesh_peers(req).await?;
                let peer_ids = peer_ids_from_bytes(res.peers)?;
                Ok(peer_ids)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_publish(
            &self,
            topic_hash: TopicHash,
            data: Bytes,
        ) -> Result<MessageId> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_publish",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(192u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["topic_hash"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&topic_hash) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&topic_hash) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GossipsubPublishRequest {
                    topic_hash: topic_hash.to_string(),
                    data,
                };
                let res = self.backend.gossipsub_publish(req).await?;
                let message_id = MessageId::new(&res.message_id);
                Ok(message_id)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_remove_explicit_peer(
            &self,
            peer_id: PeerId,
        ) -> Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_remove_explicit_peer",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(203u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["peer_id"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&peer_id) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&peer_id) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GossipsubPeerIdMsg {
                    peer_id: peer_id.to_bytes(),
                };
                self.backend.gossipsub_remove_explicit_peer(req).await?;
                Ok(())
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_subscribe(&self, topic: TopicHash) -> Result<bool> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_subscribe",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(212u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["topic"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&topic) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&topic) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GossipsubTopicHashMsg {
                    topic_hash: topic.to_string(),
                };
                let res = self.backend.gossipsub_subscribe(req).await?;
                Ok(res.was_subscribed)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_topics(&self) -> Result<Vec<TopicHash>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_topics",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(221u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let res = self.backend.gossipsub_topics(()).await?;
                let topics = res.topics.into_iter().map(TopicHash::from_raw).collect();
                Ok(topics)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn gossipsub_unsubscribe(&self, topic: TopicHash) -> Result<bool> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "gossipsub_unsubscribe",
                            "iroh_rpc_client::network",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/network.rs"),
                            Some(228u32),
                            Some("iroh_rpc_client::network"),
                            ::tracing_core::field::FieldSet::new(
                                &["topic"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&topic) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&topic) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GossipsubTopicHashMsg {
                    topic_hash: topic.to_string(),
                };
                let res = self.backend.gossipsub_unsubscribe(req).await?;
                Ok(res.was_subscribed)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
    fn peers_and_topics_from_bytes(
        pt: GossipsubPeerAndTopics,
    ) -> Result<(PeerId, Vec<TopicHash>)> {
        let peer_id = peer_id_from_bytes(pt.peer_id)?;
        let topics = pt.topics.into_iter().map(TopicHash::from_raw).collect();
        Ok((peer_id, topics))
    }
    fn all_peers_from_bytes(
        a: Vec<GossipsubPeerAndTopics>,
    ) -> Result<Vec<(PeerId, Vec<TopicHash>)>> {
        a.into_iter().map(peers_and_topics_from_bytes).collect()
    }
    fn peer_id_from_bytes(p: Vec<u8>) -> Result<PeerId> {
        PeerId::from_bytes(&p).context("invalid PeerId")
    }
    fn peer_ids_from_bytes(p: Vec<Vec<u8>>) -> Result<Vec<PeerId>> {
        p.into_iter().map(peer_id_from_bytes).collect()
    }
    fn addr_from_bytes(m: Vec<u8>) -> Result<Multiaddr> {
        Multiaddr::try_from(m).context("invalid multiaddr")
    }
    fn addrs_from_bytes(a: Vec<Vec<u8>>) -> Result<Vec<Multiaddr>> {
        a.into_iter().map(addr_from_bytes).collect()
    }
}
#[cfg(feature = "grpc")]
mod status {
    use crate::{gateway, network, store};
    use anyhow::Result;
    use async_stream::stream;
    use futures::Stream;
    use tonic::transport::channel::Channel;
    use tonic_health::proto::{
        health_check_response::ServingStatus, health_client::HealthClient,
        HealthCheckRequest, HealthCheckResponse,
    };
    const WAIT: std::time::Duration = std::time::Duration::from_millis(1000);
    pub async fn check(
        health_client: HealthClient<Channel>,
        service: &'static str,
        display_name: &'static str,
    ) -> StatusRow {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "check",
                        "iroh_rpc_client::status",
                        tracing::Level::INFO,
                        Some("iroh-rpc-client/src/status.rs"),
                        Some(14u32),
                        Some("iroh_rpc_client::status"),
                        ::tracing_core::field::FieldSet::new(
                            &["service", "display_name"],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::INFO
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                        Some(&service as &Value),
                                    ),
                                    (
                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                        Some(&display_name as &Value),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                if match tracing::Level::INFO {
                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                    _ => ::tracing::log::Level::Trace,
                } <= ::tracing::log::STATIC_MAX_LEVEL
                {
                    if !::tracing::dispatcher::has_been_set() {
                        {
                            span.record_all(
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = CALLSITE.metadata().fields().iter();
                                    CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&service as &Value),
                                                ),
                                                (
                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&display_name as &Value),
                                                ),
                                            ],
                                        )
                                },
                            );
                        }
                    } else {
                        {}
                    }
                } else {
                    {}
                };
                span
            }
        };
        let __tracing_instrument_future = async move {
            let req = iroh_metrics::req::trace_tonic_req(HealthCheckRequest {
                service: service.to_string(),
            });
            let res = health_client.clone().check(req).await;
            let status = match res {
                Ok(res) => res.into_inner().into(),
                Err(s) => ServiceStatus::Down(s),
            };
            StatusRow::new(display_name, 1, status)
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    pub async fn watch(
        health_client: HealthClient<Channel>,
        service: &'static str,
        display_name: &'static str,
    ) -> impl Stream<Item = StatusRow> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "watch",
                        "iroh_rpc_client::status",
                        tracing::Level::INFO,
                        Some("iroh-rpc-client/src/status.rs"),
                        Some(31u32),
                        Some("iroh_rpc_client::status"),
                        ::tracing_core::field::FieldSet::new(
                            &["service", "display_name"],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::INFO
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                        Some(&service as &Value),
                                    ),
                                    (
                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                        Some(&display_name as &Value),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    CALLSITE.metadata(),
                );
                if match tracing::Level::INFO {
                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                    _ => ::tracing::log::Level::Trace,
                } <= ::tracing::log::STATIC_MAX_LEVEL
                {
                    if !::tracing::dispatcher::has_been_set() {
                        {
                            span.record_all(
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = CALLSITE.metadata().fields().iter();
                                    CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&service as &Value),
                                                ),
                                                (
                                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                    Some(&display_name as &Value),
                                                ),
                                            ],
                                        )
                                },
                            );
                        }
                    } else {
                        {}
                    }
                } else {
                    {}
                };
                span
            }
        };
        let __tracing_instrument_future = async move {
            {
                let (mut __yield_tx, __yield_rx) = ::async_stream::yielder::pair();
                ::async_stream::AsyncStream::new(
                    __yield_rx,
                    async move {
                        loop {
                            let req = iroh_metrics::req::trace_tonic_req(HealthCheckRequest {
                                service: service.to_string(),
                            });
                            let res = health_client.clone().watch(req).await;
                            match res {
                                Ok(stream) => {
                                    let mut stream = stream.into_inner();
                                    loop {
                                        match stream.message().await {
                                            Ok(Some(message)) => {
                                                __yield_tx
                                                    .send(StatusRow::new(display_name, 1, message.into()))
                                                    .await
                                            }
                                            Ok(None) => {
                                                __yield_tx
                                                    .send(
                                                        StatusRow::new(
                                                            display_name,
                                                            1,
                                                            ServiceStatus::Down(
                                                                tonic::Status::new(
                                                                    tonic::Code::Unavailable,
                                                                    {
                                                                        let res = ::alloc::fmt::format(
                                                                            ::core::fmt::Arguments::new_v1(
                                                                                &["No more health messages from service `", "`"],
                                                                                &[::core::fmt::ArgumentV1::new_display(&service)],
                                                                            ),
                                                                        );
                                                                        res
                                                                    },
                                                                ),
                                                            ),
                                                        ),
                                                    )
                                                    .await;
                                                break;
                                            }
                                            Err(status) => {
                                                __yield_tx
                                                    .send(
                                                        StatusRow::new(display_name, 1, ServiceStatus::Down(status)),
                                                    )
                                                    .await;
                                                break;
                                            }
                                        }
                                    }
                                }
                                Err(status) => {
                                    __yield_tx
                                        .send(
                                            StatusRow::new(display_name, 1, ServiceStatus::Down(status)),
                                        )
                                        .await
                                }
                            }
                            tokio::time::sleep(WAIT).await;
                        };
                    },
                )
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    impl std::convert::From<HealthCheckResponse> for ServiceStatus {
        fn from(h: HealthCheckResponse) -> Self {
            match h.status() {
                ServingStatus::Unknown => ServiceStatus::Unknown,
                ServingStatus::Serving => ServiceStatus::Serving,
                ServingStatus::NotServing => ServiceStatus::NotServing,
                ServingStatus::ServiceUnknown => ServiceStatus::ServiceUnknown,
            }
        }
    }
    pub enum ServiceStatus {
        ///  Indicates rpc server is in an unknown state
        Unknown,
        /// Indicates service is serving data
        Serving,
        /// Indicates service is not serving data, but the rpc server is not down
        NotServing,
        /// Indicates that the requested service is unknown
        ServiceUnknown,
        /// Indicates that the service is down. This ServiceStatus is assigned when
        /// a `check` or `watch` call has returned an error with `tonic::Status`
        Down(tonic::Status),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ServiceStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ServiceStatus::Unknown => ::core::fmt::Formatter::write_str(f, "Unknown"),
                ServiceStatus::Serving => ::core::fmt::Formatter::write_str(f, "Serving"),
                ServiceStatus::NotServing => {
                    ::core::fmt::Formatter::write_str(f, "NotServing")
                }
                ServiceStatus::ServiceUnknown => {
                    ::core::fmt::Formatter::write_str(f, "ServiceUnknown")
                }
                ServiceStatus::Down(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Down",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl std::clone::Clone for ServiceStatus {
        fn clone(&self) -> Self {
            match self {
                ServiceStatus::Down(status) => {
                    ServiceStatus::Down(
                        tonic::Status::new(status.code(), status.message()),
                    )
                }
                ServiceStatus::Unknown => ServiceStatus::Unknown,
                ServiceStatus::Serving => ServiceStatus::Serving,
                ServiceStatus::NotServing => ServiceStatus::NotServing,
                ServiceStatus::ServiceUnknown => ServiceStatus::ServiceUnknown,
            }
        }
    }
    impl std::cmp::PartialEq for ServiceStatus {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (ServiceStatus::Unknown, ServiceStatus::Unknown) => true,
                (ServiceStatus::Serving, ServiceStatus::Serving) => true,
                (ServiceStatus::NotServing, ServiceStatus::NotServing) => true,
                (ServiceStatus::ServiceUnknown, ServiceStatus::ServiceUnknown) => true,
                (ServiceStatus::Down(s), ServiceStatus::Down(o)) => s.code() == o.code(),
                _ => false,
            }
        }
    }
    pub struct StatusRow {
        pub(crate) name: &'static str,
        pub(crate) number: usize,
        pub(crate) status: ServiceStatus,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StatusRow {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StatusRow",
                "name",
                &&self.name,
                "number",
                &&self.number,
                "status",
                &&self.status,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StatusRow {
        #[inline]
        fn clone(&self) -> StatusRow {
            StatusRow {
                name: ::core::clone::Clone::clone(&self.name),
                number: ::core::clone::Clone::clone(&self.number),
                status: ::core::clone::Clone::clone(&self.status),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for StatusRow {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StatusRow {
        #[inline]
        fn eq(&self, other: &StatusRow) -> bool {
            self.name == other.name && self.number == other.number
                && self.status == other.status
        }
        #[inline]
        fn ne(&self, other: &StatusRow) -> bool {
            self.name != other.name || self.number != other.number
                || self.status != other.status
        }
    }
    impl StatusRow {
        pub fn new(name: &'static str, number: usize, status: ServiceStatus) -> Self {
            Self { name, number, status }
        }
        pub fn name(&self) -> &'static str {
            self.name
        }
        pub fn number(&self) -> usize {
            self.number
        }
        pub fn status(&self) -> ServiceStatus {
            self.status.clone()
        }
    }
    impl Default for StatusRow {
        fn default() -> Self {
            Self {
                name: "",
                number: 1,
                status: ServiceStatus::Unknown,
            }
        }
    }
    pub struct StatusTable {
        pub gateway: StatusRow,
        pub p2p: StatusRow,
        pub store: StatusRow,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StatusTable {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StatusTable",
                "gateway",
                &&self.gateway,
                "p2p",
                &&self.p2p,
                "store",
                &&self.store,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StatusTable {
        #[inline]
        fn clone(&self) -> StatusTable {
            StatusTable {
                gateway: ::core::clone::Clone::clone(&self.gateway),
                p2p: ::core::clone::Clone::clone(&self.p2p),
                store: ::core::clone::Clone::clone(&self.store),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for StatusTable {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StatusTable {
        #[inline]
        fn eq(&self, other: &StatusTable) -> bool {
            self.gateway == other.gateway && self.p2p == other.p2p
                && self.store == other.store
        }
        #[inline]
        fn ne(&self, other: &StatusTable) -> bool {
            self.gateway != other.gateway || self.p2p != other.p2p
                || self.store != other.store
        }
    }
    impl StatusTable {
        pub fn new(
            gateway: Option<StatusRow>,
            p2p: Option<StatusRow>,
            store: Option<StatusRow>,
        ) -> Self {
            Self {
                gateway: gateway.unwrap_or_default(),
                p2p: p2p.unwrap_or_default(),
                store: store.unwrap_or_default(),
            }
        }
        pub fn update(&mut self, s: StatusRow) -> Result<()> {
            if self.gateway.name() == s.name() {
                self.gateway = s;
                return Ok(());
            }
            if self.p2p.name() == s.name() {
                self.p2p = s;
                return Ok(());
            }
            if self.store.name() == s.name() {
                self.store = s;
                return Ok(());
            }
            Err(
                ::anyhow::Error::msg({
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["unknown service "],
                            &[::core::fmt::ArgumentV1::new_display(&s.name)],
                        ),
                    );
                    res
                }),
            )
        }
    }
    impl Default for StatusTable {
        fn default() -> Self {
            Self {
                gateway: StatusRow::new(gateway::NAME, 1, ServiceStatus::Unknown),
                p2p: StatusRow::new(network::NAME, 1, ServiceStatus::Unknown),
                store: StatusRow::new(store::NAME, 1, ServiceStatus::Unknown),
            }
        }
    }
}
mod store {
    use std::io::Cursor;
    use anyhow::{Context, Result};
    use bytes::Bytes;
    use cid::Cid;
    #[cfg(feature = "grpc")]
    use futures::Stream;
    #[cfg(feature = "grpc")]
    use iroh_rpc_types::store::store_client::StoreClient as GrpcStoreClient;
    use iroh_rpc_types::store::{
        GetLinksRequest, GetRequest, HasRequest, PutRequest, Store, StoreClientAddr,
        StoreClientBackend,
    };
    use iroh_rpc_types::Addr;
    #[cfg(feature = "grpc")]
    use tonic::transport::Endpoint;
    #[cfg(feature = "grpc")]
    use tonic_health::proto::health_client::HealthClient;
    #[cfg(feature = "grpc")]
    use crate::status::{self, StatusRow};
    /// Name that the health service registers the client,
    /// as this is derived from the protobuf definition.
    #[cfg(feature = "grpc")]
    pub(crate) const SERVICE_NAME: &str = "store.Store";
    /// The display name that we expect to see in the StatusTable.
    #[cfg(feature = "grpc")]
    pub(crate) const NAME: &str = "store";
    pub struct StoreClient {
        backend: StoreClientBackend,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StoreClient {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "StoreClient",
                "backend",
                &&self.backend,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StoreClient {
        #[inline]
        fn clone(&self) -> StoreClient {
            StoreClient {
                backend: ::core::clone::Clone::clone(&self.backend),
            }
        }
    }
    impl StoreClient {
        pub async fn new(addr: StoreClientAddr) -> Result<Self> {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event iroh-rpc-client/src/store.rs:22",
                            "iroh_rpc_client::store",
                            ::tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(22u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = CALLSITE.metadata().fields().iter();
                        CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                        Some(
                                            &::core::fmt::Arguments::new_v1(
                                                &["connecting to "],
                                                &[::core::fmt::ArgumentV1::new_display(&addr)],
                                            ) as &Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = CALLSITE.metadata().fields().iter();
                                                CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                Some(
                                                                    &::core::fmt::Arguments::new_v1(
                                                                        &["connecting to "],
                                                                        &[::core::fmt::ArgumentV1::new_display(&addr)],
                                                                    ) as &Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            match addr {
                #[cfg(feature = "grpc")]
                Addr::GrpcHttp2(addr) => {
                    let conn = Endpoint::new({
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &["http://"],
                                    &[::core::fmt::ArgumentV1::new_display(&addr)],
                                ),
                            );
                            res
                        })?
                        .keep_alive_while_idle(true)
                        .connect_lazy();
                    let client = GrpcStoreClient::new(conn.clone());
                    let health = HealthClient::new(conn);
                    Ok(StoreClient {
                        backend: StoreClientBackend::Grpc {
                            client,
                            health,
                        },
                    })
                }
                #[cfg(all(feature = "grpc", unix))]
                Addr::GrpcUds(path) => {
                    use tokio::net::UnixStream;
                    use tonic::transport::Uri;
                    let path = std::sync::Arc::new(path);
                    let conn = Endpoint::new("http://[..]:50051")?
                        .keep_alive_while_idle(true)
                        .connect_with_connector_lazy(
                            tower::service_fn(move |_: Uri| {
                                let path = path.clone();
                                UnixStream::connect(path.as_ref().clone())
                            }),
                        );
                    let client = GrpcStoreClient::new(conn.clone());
                    let health = HealthClient::new(conn);
                    Ok(StoreClient {
                        backend: StoreClientBackend::Grpc {
                            client,
                            health,
                        },
                    })
                }
                #[cfg(feature = "mem")]
                Addr::Mem(s) => {
                    Ok(StoreClient {
                        backend: StoreClientBackend::Mem(s),
                    })
                }
            }
        }
        #[cfg(feature = "grpc")]
        pub async fn check(&self) -> StatusRow {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "check",
                            "iroh_rpc_client::store",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(22u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                match &self.backend {
                    StoreClientBackend::Grpc { health, .. } => {
                        status::check(health.clone(), SERVICE_NAME, NAME).await
                    }
                    _ => ::core::panicking::panic("not yet implemented"),
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[cfg(feature = "grpc")]
        pub async fn watch(&self) -> impl Stream<Item = StatusRow> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "watch",
                            "iroh_rpc_client::store",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(22u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                match &self.backend {
                    StoreClientBackend::Grpc { health, .. } => {
                        status::watch(health.clone(), SERVICE_NAME, NAME).await
                    }
                    _ => ::core::panicking::panic("not yet implemented"),
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
    impl StoreClient {
        pub async fn version(&self) -> Result<String> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "version",
                            "iroh_rpc_client::store",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(25u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{ CALLSITE.metadata().fields().value_set(&[]) },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let res = self.backend.clone().version(()).await?;
                Ok(res.version)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn put(&self, cid: Cid, blob: Bytes, links: Vec<Cid>) -> Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "put",
                            "iroh_rpc_client::store",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(31u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &["cid", "links"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&cid) as &Value),
                                        ),
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&links) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&cid) as &Value),
                                                    ),
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&links) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = PutRequest {
                    cid: cid.to_bytes(),
                    blob,
                    links: links.iter().map(|l| l.to_bytes()).collect(),
                };
                self.backend.clone().put(req).await?;
                Ok(())
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn get(&self, cid: Cid) -> Result<Option<Bytes>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get",
                            "iroh_rpc_client::store",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(42u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &["cid"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&cid) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&cid) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GetRequest { cid: cid.to_bytes() };
                let res = self.backend.clone().get(req).await?;
                Ok(res.data)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn has(&self, cid: Cid) -> Result<bool> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "has",
                            "iroh_rpc_client::store",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(51u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &["cid"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&cid) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&cid) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = HasRequest { cid: cid.to_bytes() };
                let res = self.backend.clone().has(req).await?;
                Ok(res.has)
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub async fn get_links(&self, cid: Cid) -> Result<Option<Vec<Cid>>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get_links",
                            "iroh_rpc_client::store",
                            tracing::Level::INFO,
                            Some("iroh-rpc-client/src/store.rs"),
                            Some(60u32),
                            Some("iroh_rpc_client::store"),
                            ::tracing_core::field::FieldSet::new(
                                &["cid"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::INFO <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(&tracing::field::debug(&cid) as &Value),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        CALLSITE.metadata(),
                    );
                    if match tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                span.record_all(
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = CALLSITE.metadata().fields().iter();
                                        CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                        Some(&tracing::field::debug(&cid) as &Value),
                                                    ),
                                                ],
                                            )
                                    },
                                );
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                    span
                }
            };
            let __tracing_instrument_future = async move {
                let req = GetLinksRequest {
                    cid: cid.to_bytes(),
                };
                let links = self.backend.clone().get_links(req).await?.links;
                if links.is_empty() {
                    Ok(None)
                } else {
                    let links: Result<Vec<Cid>> = links
                        .iter()
                        .map(|l| {
                            Cid::read_bytes(Cursor::new(l))
                                .context({
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["invalid cid: "],
                                            &[::core::fmt::ArgumentV1::new_debug(&l)],
                                        ),
                                    );
                                    res
                                })
                        })
                        .collect();
                    Ok(Some(links?))
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
}
pub use crate::client::Client;
pub use crate::config::Config;
#[cfg(feature = "grpc")]
pub use crate::status::{ServiceStatus, StatusRow, StatusTable};
