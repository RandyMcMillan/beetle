use std::collections::{HashMap, HashSet, VecDeque};
use std::task::{Context, Poll};
use std::time::Duration;
use std::{cmp, io};

use ahash::AHashMap;
use futures::channel::oneshot;
use libp2p::core::connection::{ConnectionId, ListenerId};
use libp2p::core::{ConnectedPoint, Multiaddr, PeerId, PublicKey};
use libp2p::kad::handler::KademliaHandlerProto;
use libp2p::kad::record::store::MemoryStore;
use libp2p::kad::record::Key;
use libp2p::kad::{GetProvidersOk, Kademlia, KademliaConfig, KademliaEvent, QueryId, QueryResult};
use libp2p::mdns::{Mdns, MdnsEvent};
use libp2p::multiaddr::Protocol;
use libp2p::swarm::behaviour::toggle::{Toggle, ToggleIntoProtoHandler};
use libp2p::swarm::{
    ConnectionHandler, DialError, IntoConnectionHandler, NetworkBehaviour, NetworkBehaviourAction,
    PollParameters,
};
use tokio::time::{self, Interval};
use tracing::{debug, error, info, trace, warn};

/// Event generated by the `DiscoveryBehaviour`.
#[derive(Debug)]
pub enum DiscoveryOut {
    /// Event that notifies that we connected to the node with the given peer id.
    Connected(PeerId),

    /// Event that notifies that we disconnected with the node with the given peer id.
    Disconnected(PeerId),
}

/// `DiscoveryBehaviour` configuration.
///
/// Note: In order to discover nodes or load and store values via Kademlia one has to add at least
///       one protocol via [`DiscoveryConfig::add_protocol`].
pub struct DiscoveryConfig {
    local_peer_id: PeerId,
    user_defined: Vec<Multiaddr>,
    discovery_max: u64,
    enable_mdns: bool,
    enable_kademlia: bool,
}

impl DiscoveryConfig {
    /// Create a default configuration with the given public key.
    pub fn new(local_public_key: PublicKey) -> Self {
        DiscoveryConfig {
            local_peer_id: local_public_key.to_peer_id(),
            user_defined: Vec::new(),
            discovery_max: std::u64::MAX,
            enable_mdns: false,
            enable_kademlia: true,
        }
    }

    /// Set the number of active connections at which we pause discovery.
    pub fn discovery_limit(&mut self, limit: u64) -> &mut Self {
        self.discovery_max = limit;
        self
    }

    /// Set custom nodes which never expire, e.g. bootstrap or reserved nodes.
    pub fn with_user_defined<I>(&mut self, user_defined: I) -> &mut Self
    where
        I: IntoIterator<Item = Multiaddr>,
    {
        self.user_defined.extend(user_defined);
        self
    }

    /// Configures if mdns is enabled.
    pub fn with_mdns(&mut self, value: bool) -> &mut Self {
        self.enable_mdns = value;
        self
    }

    /// Configures if Kademlia is enabled.
    pub fn with_kademlia(&mut self, value: bool) -> &mut Self {
        self.enable_kademlia = value;
        self
    }

    /// Create a `DiscoveryBehaviour` from this config.
    pub async fn finish(self) -> DiscoveryBehaviour {
        let DiscoveryConfig {
            local_peer_id,
            user_defined,
            discovery_max,
            enable_mdns,
            enable_kademlia,
        } = self;

        let mut peers = HashSet::new();
        let peer_addresses = HashMap::new();

        // Kademlia config
        let store = MemoryStore::new(local_peer_id.to_owned());
        let kad_config = KademliaConfig::default();
        // default to using the IPFS network

        // TODO: this parsing should probably be done when parsing config, not initializing node
        let user_defined: Vec<(PeerId, Multiaddr)> = user_defined
            .into_iter()
            .filter_map(|multiaddr| {
                let mut addr = multiaddr.to_owned();
                if let Some(Protocol::P2p(mh)) = addr.pop() {
                    let peer_id = PeerId::from_multihash(mh).unwrap();
                    Some((peer_id, addr))
                } else {
                    warn!("Could not parse bootstrap addr {}", multiaddr);
                    None
                }
            })
            .collect();

        let kademlia_opt = if enable_kademlia {
            let mut kademlia = Kademlia::with_config(local_peer_id, store, kad_config);
            for (peer_id, addr) in user_defined.iter() {
                kademlia.add_address(peer_id, addr.clone());
                peers.insert(*peer_id);
            }
            if let Err(e) = kademlia.bootstrap() {
                warn!("Kademlia bootstrap failed: {}", e);
            }
            Some(kademlia)
        } else {
            None
        };

        let mdns_opt = if enable_mdns {
            Some(
                Mdns::new(Default::default())
                    .await
                    .expect("Could not start mDNS"),
            )
        } else {
            None
        };

        let duration_to_next_kad = Duration::from_secs(5);

        DiscoveryBehaviour {
            user_defined,
            kademlia: kademlia_opt.into(),
            next_kad_random_query: time::interval(duration_to_next_kad),
            duration_to_next_kad,
            pending_events: VecDeque::new(),
            num_connections: 0,
            mdns: mdns_opt.into(),
            peer_addresses,
            discovery_max,
            queries: Default::default(),
        }
    }
}

/// Implementation of `NetworkBehaviour` that discovers the nodes on the network.
pub struct DiscoveryBehaviour {
    /// User-defined list of nodes and their addresses. Typically includes bootstrap nodes and
    /// reserved nodes.
    user_defined: Vec<(PeerId, Multiaddr)>,
    /// Kademlia discovery.
    kademlia: Toggle<Kademlia<MemoryStore>>,
    /// Discovers nodes on the local network.
    mdns: Toggle<Mdns>,
    /// Stream that fires when we need to perform the next random Kademlia query.
    next_kad_random_query: Interval,
    /// After `next_kad_random_query` triggers, the next one triggers after this duration.
    duration_to_next_kad: Duration,
    /// Events to return in priority when polled.
    pending_events: VecDeque<DiscoveryOut>,
    /// Number of nodes we're currently connected to.
    num_connections: u64,
    /// Keeps hash map of peers and their multiaddresses
    peer_addresses: HashMap<PeerId, Vec<Multiaddr>>,
    /// Number of active connections to pause discovery on.
    discovery_max: u64,

    queries: AHashMap<QueryId, QueryChannel>,
}

enum QueryChannel {
    GetProviders(oneshot::Sender<Result<HashSet<PeerId>, String>>),
}

impl DiscoveryBehaviour {
    /// Returns a map of peer ids and their multiaddresses
    pub fn peer_addresses(&self) -> &HashMap<PeerId, Vec<Multiaddr>> {
        &self.peer_addresses
    }

    /// Bootstrap Kademlia network
    pub fn bootstrap(&mut self) -> Result<QueryId, String> {
        if let Some(active_kad) = self.kademlia.as_mut() {
            active_kad.bootstrap().map_err(|e| e.to_string())
        } else {
            Err("Kademlia is not activated".to_string())
        }
    }

    pub fn add_address(&mut self, peer: &PeerId, addr: Multiaddr) {
        if let Some(kad) = self.kademlia.as_mut() {
            kad.add_address(peer, addr);
        }
    }

    pub fn providers(
        &mut self,
        key: Key,
        response_channel: oneshot::Sender<Result<HashSet<PeerId>, String>>,
    ) {
        if let Some(kad) = self.kademlia.as_mut() {
            let id = kad.get_providers(key);
            self.queries
                .insert(id, QueryChannel::GetProviders(response_channel));
        } else {
            response_channel.send(Ok(Default::default())).ok();
        }
    }
}

impl NetworkBehaviour for DiscoveryBehaviour {
    type ConnectionHandler = ToggleIntoProtoHandler<KademliaHandlerProto<QueryId>>;
    type OutEvent = DiscoveryOut;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        self.kademlia.new_handler()
    }

    fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        let mut list = self
            .user_defined
            .iter()
            .filter_map(|(p, a)| if p == peer_id { Some(a.clone()) } else { None })
            .collect::<Vec<_>>();

        {
            let mut list_to_filter = Vec::new();
            if let Some(k) = self.kademlia.as_mut() {
                list_to_filter.extend(k.addresses_of_peer(peer_id))
            }

            list_to_filter.extend(self.mdns.addresses_of_peer(peer_id));

            list.extend(list_to_filter);
        }

        trace!("Addresses of {:?}: {:?}", peer_id, list);

        list
    }

    fn inject_connection_established(
        &mut self,
        peer_id: &PeerId,
        conn: &ConnectionId,
        endpoint: &ConnectedPoint,
        failed_addresses: Option<&Vec<Multiaddr>>,
        remaining: usize,
    ) {
        let addrs = self.peer_addresses.entry(*peer_id).or_insert(Vec::new());
        let new_peer = addrs.is_empty();
        addrs.push(endpoint.get_remote_address().clone());
        if new_peer {
            // New Peer
            self.pending_events
                .push_back(DiscoveryOut::Connected(*peer_id));
            self.num_connections += 1;
        }

        self.kademlia.inject_connection_established(
            peer_id,
            conn,
            endpoint,
            failed_addresses,
            remaining,
        );
    }

    fn inject_connection_closed(
        &mut self,
        peer_id: &PeerId,
        conn: &ConnectionId,
        endpoint: &ConnectedPoint,
        handler: <Self::ConnectionHandler as IntoConnectionHandler>::Handler,
        remaining: usize,
    ) {
        let removed_addr = endpoint.get_remote_address();
        let last_addr = if let Some(addrs) = self.peer_addresses.get_mut(peer_id) {
            addrs.retain(|addr| addr != removed_addr);
            addrs.is_empty()
        } else {
            true
        };
        if last_addr {
            self.pending_events
                .push_back(DiscoveryOut::Disconnected(*peer_id));
        }
        self.kademlia
            .inject_connection_closed(peer_id, conn, endpoint, handler, remaining);
    }

    fn inject_event(
        &mut self,
        peer_id: PeerId,
        connection: ConnectionId,
        event: <<Self::ConnectionHandler as IntoConnectionHandler>::Handler as ConnectionHandler>::OutEvent,
    ) {
        if let Some(kad) = self.kademlia.as_mut() {
            return kad.inject_event(peer_id, connection, event);
        }
        error!("inject_node_event: no kademlia instance registered for protocol")
    }

    fn inject_new_external_addr(&mut self, addr: &Multiaddr) {
        self.kademlia.inject_new_external_addr(addr)
    }

    fn inject_expired_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        self.kademlia.inject_expired_listen_addr(id, addr);
    }

    fn inject_dial_failure(
        &mut self,
        peer_id: Option<PeerId>,
        handler: Self::ConnectionHandler,
        err: &DialError,
    ) {
        self.kademlia.inject_dial_failure(peer_id, handler, err)
    }

    fn inject_new_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        self.kademlia.inject_new_listen_addr(id, addr)
    }

    fn inject_listener_error(&mut self, id: ListenerId, err: &(dyn std::error::Error + 'static)) {
        self.kademlia.inject_listener_error(id, err)
    }

    fn inject_listener_closed(&mut self, id: ListenerId, reason: Result<(), &io::Error>) {
        self.kademlia.inject_listener_closed(id, reason)
    }

    fn poll(
        &mut self,
        cx: &mut Context,
        params: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
        // Immediately process the content of `discovered`.
        if let Some(ev) = self.pending_events.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
        }

        // Poll the stream that fires when we need to start a random Kademlia query.
        if let Poll::Ready(_instant) = self.next_kad_random_query.poll_tick(cx) {
            if self.num_connections < self.discovery_max {
                // We still have not hit the discovery max, send random request for peers.
                let random_peer_id = PeerId::random();
                debug!(
                    "Libp2p <= Starting random Kademlia request for {:?}",
                    random_peer_id
                );
                if let Some(k) = self.kademlia.as_mut() {
                    k.get_closest_peers(random_peer_id);
                }
            }

            // Schedule the next random query with exponentially increasing delay,
            // capped at 60 seconds.
            self.duration_to_next_kad =
                cmp::min(self.duration_to_next_kad * 2, Duration::from_secs(60));
            if self.next_kad_random_query.period() != self.duration_to_next_kad {
                self.next_kad_random_query = time::interval(self.duration_to_next_kad);
                // tick once, as Interval ticks once immediately
                let _ = self.next_kad_random_query.poll_tick(cx);
            }
        }

        // Poll Kademlia.
        while let Poll::Ready(ev) = self.kademlia.poll(cx, params) {
            match ev {
                NetworkBehaviourAction::GenerateEvent(ev) => match ev {
                    // Adding to Kademlia buckets is automatic with our config,
                    // no need to do manually.
                    KademliaEvent::RoutingUpdated { .. } => {}
                    KademliaEvent::RoutablePeer { .. } => {}
                    KademliaEvent::PendingRoutablePeer { .. } => {
                        // Intentionally ignore
                    }
                    KademliaEvent::OutboundQueryCompleted { id, result, .. } => {
                        info!("kad: {:?}", result);
                        match result {
                            QueryResult::GetProviders(Ok(GetProvidersOk { providers, .. })) => {
                                if let Some(QueryChannel::GetProviders(ch)) =
                                    self.queries.remove(&id)
                                {
                                    ch.send(Ok(providers)).ok();
                                }
                            }
                            QueryResult::GetProviders(Err(err)) => {
                                trace!("{:?}", err);
                                if let Some(QueryChannel::GetProviders(ch)) =
                                    self.queries.remove(&id)
                                {
                                    ch.send(Err(err.to_string())).ok();
                                }
                            }
                            other => {
                                debug!("Libp2p => Unhandled Kademlia query result: {:?}", other)
                            }
                        }
                    }
                    other => {
                        debug!("Libp2p => Unhandled Kademlia event: {:?}", other)
                    }
                },
                NetworkBehaviourAction::Dial { opts, handler } => {
                    return Poll::Ready(NetworkBehaviourAction::Dial { opts, handler })
                }
                NetworkBehaviourAction::NotifyHandler {
                    peer_id,
                    handler,
                    event,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::NotifyHandler {
                        peer_id,
                        handler,
                        event,
                    })
                }
                NetworkBehaviourAction::ReportObservedAddr { address, score } => {
                    return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
                        address,
                        score,
                    })
                }
                NetworkBehaviourAction::CloseConnection {
                    peer_id,
                    connection,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::CloseConnection {
                        peer_id,
                        connection,
                    })
                }
            }
        }

        // Poll mdns.
        while let Poll::Ready(ev) = self.mdns.poll(cx, params) {
            match ev {
                NetworkBehaviourAction::GenerateEvent(event) => match event {
                    MdnsEvent::Discovered(list) => {
                        if self.num_connections >= self.discovery_max {
                            // Already over discovery max, don't add discovered peers.
                            // We could potentially buffer these addresses to be added later,
                            // but mdns is not an important use case and may be removed in future.
                            continue;
                        }

                        // Add any discovered peers to Kademlia
                        for (peer_id, multiaddr) in list {
                            if let Some(kad) = self.kademlia.as_mut() {
                                kad.add_address(&peer_id, multiaddr);
                            }
                        }
                    }
                    MdnsEvent::Expired(_) => {}
                },
                NetworkBehaviourAction::Dial { .. } => {}
                // Nothing to notify handler
                NetworkBehaviourAction::NotifyHandler { event, .. } => match event {},
                NetworkBehaviourAction::ReportObservedAddr { address, score } => {
                    return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
                        address,
                        score,
                    })
                }
                NetworkBehaviourAction::CloseConnection {
                    peer_id,
                    connection,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::CloseConnection {
                        peer_id,
                        connection,
                    })
                }
            }
        }

        // Poll pending events
        if let Some(ev) = self.pending_events.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
        }

        Poll::Pending
    }
}
